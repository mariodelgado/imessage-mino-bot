{"version":3,"file":"edge-chunks/891.js","mappings":"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","sources":["webpack://_N_E/./src/lib/storage.ts"],"sourcesContent":["/**\n * Snap App Storage - Vercel KV + Blob based storage\n *\n * Primary storage for Snap Apps with support for:\n * - Fast KV lookups by ID\n * - Blob storage for large data payloads\n * - Atomic counters for view/share tracking\n * - TTL support for temporary/scheduled apps\n */\n\nimport { kv as vercelKv } from \"@vercel/kv\";\nimport { nanoid } from \"nanoid\";\n\n// ============================================================================\n// LOCAL STORAGE FALLBACK (for development without KV)\n// ============================================================================\n\nconst localStore = new Map<string, unknown>();\nconst localSortedSets = new Map<string, Array<{ score: number; member: string }>>();\n\nconst isKvConfigured = Boolean(\n  process.env.KV_REST_API_URL && process.env.KV_REST_API_TOKEN\n);\n\n// Define a minimal KV interface that works for both implementations\ninterface KvInterface {\n  get<T>(key: string): Promise<T | null>;\n  set(key: string, value: unknown, options?: { ex?: number }): Promise<unknown>;\n  del(key: string): Promise<unknown>;\n  incr(key: string): Promise<number>;\n  zadd(key: string, item: { score: number; member: string }): Promise<unknown>;\n  zrem(key: string, member: string): Promise<unknown>;\n  zrange<T>(key: string, start: number, stop: number, options?: { rev?: boolean; byScore?: boolean }): Promise<T[]>;\n}\n\n// KV-compatible interface for local development\nconst localKv: KvInterface = {\n  async get<T>(key: string): Promise<T | null> {\n    return (localStore.get(key) as T) ?? null;\n  },\n  async set(key: string, value: unknown): Promise<void> {\n    localStore.set(key, value);\n  },\n  async del(key: string): Promise<void> {\n    localStore.delete(key);\n  },\n  async incr(key: string): Promise<number> {\n    const current = (localStore.get(key) as number) || 0;\n    const next = current + 1;\n    localStore.set(key, next);\n    return next;\n  },\n  async zadd(key: string, item: { score: number; member: string }): Promise<void> {\n    const set = localSortedSets.get(key) || [];\n    const existingIdx = set.findIndex(s => s.member === item.member);\n    if (existingIdx >= 0) {\n      set[existingIdx] = item;\n    } else {\n      set.push(item);\n    }\n    set.sort((a, b) => a.score - b.score);\n    localSortedSets.set(key, set);\n  },\n  async zrem(key: string, member: string): Promise<void> {\n    const set = localSortedSets.get(key) || [];\n    const idx = set.findIndex(s => s.member === member);\n    if (idx >= 0) {\n      set.splice(idx, 1);\n      localSortedSets.set(key, set);\n    }\n  },\n  async zrange<T>(\n    key: string,\n    start: number,\n    stop: number,\n    options?: { rev?: boolean; byScore?: boolean }\n  ): Promise<T[]> {\n    let set = [...(localSortedSets.get(key) || [])];\n    if (options?.rev) {\n      set = set.reverse();\n    }\n    if (options?.byScore) {\n      // For byScore, start/stop are scores not indices\n      set = set.filter(s => s.score >= start && s.score <= stop);\n    } else {\n      set = set.slice(start, stop + 1);\n    }\n    return set.map(s => s.member) as T[];\n  },\n};\n\n// Use Vercel KV if configured, otherwise use local storage\n// Cast to KvInterface to avoid union type incompatibility\nconst kv: KvInterface = isKvConfigured ? (vercelKv as unknown as KvInterface) : localKv;\n\nif (!isKvConfigured) {\n  console.log(\"⚠️  Using in-memory storage (KV not configured)\");\n}\nimport type {\n  SnapApp,\n  CreateSnapAppRequest,\n  UpdateSnapAppRequest,\n  ScheduledJob,\n} from \"@/types/snap-app\";\n\n// ============================================================================\n// STORAGE KEYS\n// ============================================================================\n\nconst KEYS = {\n  // Snap App by ID\n  snapApp: (id: string) => `snap:${id}`,\n\n  // User's snap apps list\n  userSnapApps: (userId: string) => `user:${userId}:snaps`,\n\n  // All public snap apps (for discovery/trending)\n  publicSnapApps: () => `public:snaps`,\n\n  // Scheduled jobs\n  scheduledJob: (id: string) => `schedule:${id}`,\n\n  // Jobs by snap app\n  snapAppSchedule: (snapAppId: string) => `snap:${snapAppId}:schedule`,\n\n  // Pending scheduled jobs (sorted set by next run time)\n  pendingJobs: () => `jobs:pending`,\n\n  // View counter\n  viewCount: (id: string) => `views:${id}`,\n\n  // Share counter\n  shareCount: (id: string) => `shares:${id}`,\n};\n\n// ============================================================================\n// SNAP APP CRUD\n// ============================================================================\n\n/**\n * Create a new Snap App\n */\nexport async function createSnapApp(\n  request: CreateSnapAppRequest\n): Promise<SnapApp> {\n  const id = nanoid(10); // Short, URL-friendly ID\n  const now = new Date();\n\n  const snapApp: SnapApp = {\n    id,\n    type: request.type,\n    title: request.title,\n    subtitle: request.subtitle,\n    sourceUrl: request.sourceUrl,\n    shareUrl: `${process.env.NEXT_PUBLIC_BASE_URL || \"https://minnow.so\"}/app/${id}`,\n    data: request.data,\n    insights: request.insights,\n    actions: request.actions,\n    creatorId: request.creatorId,\n    creatorName: request.creatorName,\n    createdAt: now,\n    updatedAt: now,\n    viewCount: 0,\n    shareCount: 0,\n    isPublic: request.isPublic,\n  };\n\n  // Store the snap app\n  await kv.set(KEYS.snapApp(id), snapApp);\n\n  // Add to public list if public\n  if (snapApp.isPublic) {\n    await kv.zadd(KEYS.publicSnapApps(), {\n      score: now.getTime(),\n      member: id,\n    });\n  }\n\n  // Add to user's list if creator specified\n  if (snapApp.creatorId) {\n    await kv.zadd(KEYS.userSnapApps(snapApp.creatorId), {\n      score: now.getTime(),\n      member: id,\n    });\n  }\n\n  return snapApp;\n}\n\n/**\n * Get a Snap App by ID\n */\nexport async function getSnapApp(id: string): Promise<SnapApp | null> {\n  const snapApp = await kv.get<SnapApp>(KEYS.snapApp(id));\n  return snapApp;\n}\n\n/**\n * Get a Snap App by ID and increment view count\n */\nexport async function getSnapAppWithView(id: string): Promise<SnapApp | null> {\n  const snapApp = await kv.get<SnapApp>(KEYS.snapApp(id));\n\n  if (snapApp) {\n    // Increment view counter atomically\n    await kv.incr(KEYS.viewCount(id));\n\n    // Periodically sync view count to main record (every 10 views)\n    const viewCount = await kv.get<number>(KEYS.viewCount(id));\n    if (viewCount && viewCount % 10 === 0) {\n      await kv.set(KEYS.snapApp(id), {\n        ...snapApp,\n        viewCount,\n        updatedAt: new Date(),\n      });\n    }\n\n    return {\n      ...snapApp,\n      viewCount: viewCount || snapApp.viewCount,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Update a Snap App\n */\nexport async function updateSnapApp(\n  id: string,\n  updates: UpdateSnapAppRequest\n): Promise<SnapApp | null> {\n  const existing = await kv.get<SnapApp>(KEYS.snapApp(id));\n\n  if (!existing) {\n    return null;\n  }\n\n  const updated: SnapApp = {\n    ...existing,\n    ...updates,\n    updatedAt: new Date(),\n  };\n\n  await kv.set(KEYS.snapApp(id), updated);\n\n  // Update public list visibility\n  if (updates.isPublic !== undefined) {\n    if (updates.isPublic && !existing.isPublic) {\n      await kv.zadd(KEYS.publicSnapApps(), {\n        score: existing.createdAt.getTime(),\n        member: id,\n      });\n    } else if (!updates.isPublic && existing.isPublic) {\n      await kv.zrem(KEYS.publicSnapApps(), id);\n    }\n  }\n\n  return updated;\n}\n\n/**\n * Delete a Snap App\n */\nexport async function deleteSnapApp(id: string): Promise<boolean> {\n  const existing = await kv.get<SnapApp>(KEYS.snapApp(id));\n\n  if (!existing) {\n    return false;\n  }\n\n  // Remove from all indices\n  await Promise.all([\n    kv.del(KEYS.snapApp(id)),\n    kv.del(KEYS.viewCount(id)),\n    kv.del(KEYS.shareCount(id)),\n    kv.zrem(KEYS.publicSnapApps(), id),\n    existing.creatorId\n      ? kv.zrem(KEYS.userSnapApps(existing.creatorId), id)\n      : Promise.resolve(),\n  ]);\n\n  return true;\n}\n\n/**\n * Increment share count\n */\nexport async function incrementShareCount(id: string): Promise<number> {\n  const count = await kv.incr(KEYS.shareCount(id));\n\n  // Periodically sync to main record\n  if (count % 5 === 0) {\n    const snapApp = await kv.get<SnapApp>(KEYS.snapApp(id));\n    if (snapApp) {\n      await kv.set(KEYS.snapApp(id), {\n        ...snapApp,\n        shareCount: count,\n        updatedAt: new Date(),\n      });\n    }\n  }\n\n  return count;\n}\n\n// ============================================================================\n// LISTING OPERATIONS\n// ============================================================================\n\n/**\n * Get recent public Snap Apps\n */\nexport async function getRecentPublicSnapApps(\n  limit: number = 20,\n  offset: number = 0\n): Promise<SnapApp[]> {\n  // Get IDs from sorted set (newest first)\n  const ids = await kv.zrange<string>(KEYS.publicSnapApps(), offset, offset + limit - 1, {\n    rev: true,\n  });\n\n  if (!ids.length) {\n    return [];\n  }\n\n  // Batch fetch all snap apps\n  const snapApps = await Promise.all(ids.map((id) => getSnapApp(id)));\n\n  return snapApps.filter((app): app is SnapApp => app !== null);\n}\n\n/**\n * Get a user's Snap Apps\n */\nexport async function getUserSnapApps(\n  userId: string,\n  limit: number = 50,\n  offset: number = 0\n): Promise<SnapApp[]> {\n  const ids = await kv.zrange<string>(\n    KEYS.userSnapApps(userId),\n    offset,\n    offset + limit - 1,\n    { rev: true }\n  );\n\n  if (!ids.length) {\n    return [];\n  }\n\n  const snapApps = await Promise.all(ids.map((id) => getSnapApp(id)));\n\n  return snapApps.filter((app): app is SnapApp => app !== null);\n}\n\n// ============================================================================\n// SCHEDULING OPERATIONS\n// ============================================================================\n\n/**\n * Create a scheduled job for a Snap App\n */\nexport async function createScheduledJob(\n  snapAppId: string,\n  options: {\n    cronExpression?: string;\n    intervalMinutes?: number;\n    webhookUrl?: string;\n  }\n): Promise<ScheduledJob> {\n  const id = nanoid(10);\n  const now = new Date();\n\n  // Calculate next run time\n  let nextRunAt: Date;\n  if (options.intervalMinutes) {\n    nextRunAt = new Date(now.getTime() + options.intervalMinutes * 60 * 1000);\n  } else {\n    // Default to 1 hour if no schedule specified\n    nextRunAt = new Date(now.getTime() + 60 * 60 * 1000);\n  }\n\n  const job: ScheduledJob = {\n    id,\n    snapAppId,\n    cronExpression: options.cronExpression,\n    intervalMinutes: options.intervalMinutes,\n    webhookUrl: options.webhookUrl,\n    nextRunAt,\n    isActive: true,\n    createdAt: now,\n  };\n\n  // Store the job\n  await kv.set(KEYS.scheduledJob(id), job);\n\n  // Link to snap app\n  await kv.set(KEYS.snapAppSchedule(snapAppId), id);\n\n  // Add to pending jobs queue\n  await kv.zadd(KEYS.pendingJobs(), {\n    score: nextRunAt.getTime(),\n    member: id,\n  });\n\n  // Update snap app with schedule info\n  const snapApp = await getSnapApp(snapAppId);\n  if (snapApp) {\n    await updateSnapApp(snapAppId, {});\n    await kv.set(KEYS.snapApp(snapAppId), {\n      ...snapApp,\n      scheduleId: id,\n      refreshInterval: options.intervalMinutes,\n    });\n  }\n\n  return job;\n}\n\n/**\n * Get pending jobs that need to run\n */\nexport async function getPendingJobs(limit: number = 10): Promise<ScheduledJob[]> {\n  const now = Date.now();\n\n  // Get jobs due to run\n  const jobIds = await kv.zrange<string>(KEYS.pendingJobs(), 0, now, {\n    byScore: true,\n  });\n\n  if (!jobIds.length) {\n    return [];\n  }\n\n  // Limit to batch size\n  const batchIds = jobIds.slice(0, limit);\n\n  const jobs = await Promise.all(\n    batchIds.map((id) => kv.get<ScheduledJob>(KEYS.scheduledJob(id)))\n  );\n\n  return jobs.filter((job): job is ScheduledJob => job !== null && job.isActive);\n}\n\n/**\n * Mark a job as completed and reschedule if needed\n */\nexport async function completeScheduledJob(jobId: string): Promise<void> {\n  const job = await kv.get<ScheduledJob>(KEYS.scheduledJob(jobId));\n\n  if (!job) {\n    return;\n  }\n\n  const now = new Date();\n\n  // Calculate next run time\n  let nextRunAt: Date | undefined;\n  if (job.intervalMinutes) {\n    nextRunAt = new Date(now.getTime() + job.intervalMinutes * 60 * 1000);\n  }\n\n  // Update job\n  const updatedJob: ScheduledJob = {\n    ...job,\n    lastRunAt: now,\n    nextRunAt,\n  };\n\n  await kv.set(KEYS.scheduledJob(jobId), updatedJob);\n\n  // Remove from current position in queue\n  await kv.zrem(KEYS.pendingJobs(), jobId);\n\n  // Re-add with new run time if recurring\n  if (nextRunAt) {\n    await kv.zadd(KEYS.pendingJobs(), {\n      score: nextRunAt.getTime(),\n      member: jobId,\n    });\n  }\n\n  // Update snap app's last refresh time\n  await kv.set(KEYS.snapApp(job.snapAppId), {\n    ...(await getSnapApp(job.snapAppId)),\n    lastRefreshedAt: now,\n    updatedAt: now,\n  });\n}\n\n/**\n * Cancel a scheduled job\n */\nexport async function cancelScheduledJob(jobId: string): Promise<void> {\n  const job = await kv.get<ScheduledJob>(KEYS.scheduledJob(jobId));\n\n  if (!job) {\n    return;\n  }\n\n  // Mark as inactive\n  await kv.set(KEYS.scheduledJob(jobId), {\n    ...job,\n    isActive: false,\n  });\n\n  // Remove from queue\n  await kv.zrem(KEYS.pendingJobs(), jobId);\n\n  // Clear schedule from snap app\n  await kv.set(KEYS.snapAppSchedule(job.snapAppId), null);\n\n  const snapApp = await getSnapApp(job.snapAppId);\n  if (snapApp) {\n    await kv.set(KEYS.snapApp(job.snapAppId), {\n      ...snapApp,\n      scheduleId: undefined,\n      refreshInterval: undefined,\n    });\n  }\n}\n\n// ============================================================================\n// INVESTOR PREFERENCES\n// ============================================================================\n\nexport interface InvestorPreferences {\n  investorId: string;\n  briefSchedule: {\n    enabled: boolean;\n    time: string; // \"06:00\" format (PST)\n    timezone: string;\n    weekdaysOnly: boolean;\n    daysOfWeek: number[]; // 0=Sunday, 1=Monday, etc.\n  };\n  notifications: {\n    criticalAlerts: boolean;\n    dailyDigest: boolean;\n    weeklyReport: boolean;\n  };\n  displayPreferences: {\n    showAllNews: boolean;\n    compactView: boolean;\n    priorityThreshold: \"all\" | \"high\" | \"critical\";\n  };\n  updatedAt: Date;\n  createdAt: Date;\n}\n\nexport interface InvestorFeedback {\n  id: string;\n  investorId: string;\n  type: \"bug\" | \"feature\" | \"general\" | \"news_quality\";\n  message: string;\n  context?: {\n    page?: string;\n    newsItemId?: string;\n    company?: string;\n  };\n  status: \"pending\" | \"reviewed\" | \"resolved\";\n  createdAt: Date;\n}\n\n// Add investor-specific keys\nconst INVESTOR_KEYS = {\n  preferences: (investorId: string) => `investor:${investorId}:preferences`,\n  feedback: (investorId: string) => `investor:${investorId}:feedback`,\n  feedbackItem: (id: string) => `feedback:${id}`,\n  allFeedback: () => `feedback:all`,\n};\n\n/**\n * Get investor preferences\n */\nexport async function getInvestorPreferences(\n  investorId: string\n): Promise<InvestorPreferences | null> {\n  const prefs = await kv.get<InvestorPreferences>(INVESTOR_KEYS.preferences(investorId));\n  return prefs;\n}\n\n/**\n * Save investor preferences\n */\nexport async function saveInvestorPreferences(\n  investorId: string,\n  preferences: Partial<Omit<InvestorPreferences, \"investorId\" | \"createdAt\" | \"updatedAt\">>\n): Promise<InvestorPreferences> {\n  const existing = await getInvestorPreferences(investorId);\n  const now = new Date();\n\n  const defaultPrefs: InvestorPreferences = {\n    investorId,\n    briefSchedule: {\n      enabled: true,\n      time: \"06:00\",\n      timezone: \"America/Los_Angeles\",\n      weekdaysOnly: false,\n      daysOfWeek: [1, 2, 3, 4, 5], // Mon-Fri by default\n    },\n    notifications: {\n      criticalAlerts: true,\n      dailyDigest: true,\n      weeklyReport: false,\n    },\n    displayPreferences: {\n      showAllNews: true,\n      compactView: false,\n      priorityThreshold: \"all\",\n    },\n    createdAt: existing?.createdAt || now,\n    updatedAt: now,\n  };\n\n  const merged: InvestorPreferences = {\n    ...defaultPrefs,\n    ...existing,\n    ...preferences,\n    investorId,\n    briefSchedule: {\n      ...defaultPrefs.briefSchedule,\n      ...existing?.briefSchedule,\n      ...preferences.briefSchedule,\n    },\n    notifications: {\n      ...defaultPrefs.notifications,\n      ...existing?.notifications,\n      ...preferences.notifications,\n    },\n    displayPreferences: {\n      ...defaultPrefs.displayPreferences,\n      ...existing?.displayPreferences,\n      ...preferences.displayPreferences,\n    },\n    updatedAt: now,\n    createdAt: existing?.createdAt || now,\n  };\n\n  await kv.set(INVESTOR_KEYS.preferences(investorId), merged);\n  return merged;\n}\n\n/**\n * Add investor feedback\n */\nexport async function addInvestorFeedback(\n  investorId: string,\n  feedback: Omit<InvestorFeedback, \"id\" | \"investorId\" | \"status\" | \"createdAt\">\n): Promise<InvestorFeedback> {\n  const id = nanoid(10);\n  const now = new Date();\n\n  const feedbackItem: InvestorFeedback = {\n    id,\n    investorId,\n    type: feedback.type,\n    message: feedback.message,\n    context: feedback.context,\n    status: \"pending\",\n    createdAt: now,\n  };\n\n  // Store the feedback item\n  await kv.set(INVESTOR_KEYS.feedbackItem(id), feedbackItem);\n\n  // Add to investor's feedback list\n  await kv.zadd(INVESTOR_KEYS.feedback(investorId), {\n    score: now.getTime(),\n    member: id,\n  });\n\n  // Add to global feedback list\n  await kv.zadd(INVESTOR_KEYS.allFeedback(), {\n    score: now.getTime(),\n    member: id,\n  });\n\n  return feedbackItem;\n}\n\n/**\n * Get investor's feedback history\n */\nexport async function getInvestorFeedback(\n  investorId: string,\n  limit: number = 20\n): Promise<InvestorFeedback[]> {\n  const ids = await kv.zrange<string>(\n    INVESTOR_KEYS.feedback(investorId),\n    0,\n    limit - 1,\n    { rev: true }\n  );\n\n  if (!ids.length) {\n    return [];\n  }\n\n  const feedbackItems = await Promise.all(\n    ids.map((id) => kv.get<InvestorFeedback>(INVESTOR_KEYS.feedbackItem(id)))\n  );\n\n  return feedbackItems.filter((item): item is InvestorFeedback => item !== null);\n}\n\n/**\n * Update feedback status\n */\nexport async function updateFeedbackStatus(\n  feedbackId: string,\n  status: InvestorFeedback[\"status\"]\n): Promise<InvestorFeedback | null> {\n  const feedback = await kv.get<InvestorFeedback>(INVESTOR_KEYS.feedbackItem(feedbackId));\n\n  if (!feedback) {\n    return null;\n  }\n\n  const updated = { ...feedback, status };\n  await kv.set(INVESTOR_KEYS.feedbackItem(feedbackId), updated);\n  return updated;\n}\n\n// ============================================================================\n// INVESTOR ONBOARDING & STATE\n// ============================================================================\n\nexport interface InvestorState {\n  investorId: string;\n  stage: \"new\" | \"searched\" | \"created_app\" | \"active\";\n  hasCompletedOnboarding: boolean;\n  searchCount: number;\n  snapAppCount: number;\n  lastSearchQuery?: string;\n  lastSearchAt?: Date;\n  conversationHistory: ConversationMessage[];\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface ConversationMessage {\n  id: string;\n  role: \"user\" | \"assistant\" | \"system\";\n  content: string;\n  timestamp: Date;\n  metadata?: {\n    intent?: \"search\" | \"create_app\" | \"settings\" | \"help\" | \"general\";\n    searchResults?: unknown;\n    settingsChanged?: Record<string, unknown>;\n  };\n}\n\nconst ONBOARDING_KEYS = {\n  state: (investorId: string) => `investor:${investorId}:state`,\n  conversation: (investorId: string) => `investor:${investorId}:conversation`,\n};\n\n/**\n * Get investor onboarding state\n */\nexport async function getInvestorState(investorId: string): Promise<InvestorState | null> {\n  const state = await kv.get<InvestorState>(ONBOARDING_KEYS.state(investorId));\n  return state;\n}\n\n/**\n * Initialize investor state for new users\n */\nexport async function initializeInvestorState(investorId: string, investorName: string): Promise<InvestorState> {\n  const existing = await getInvestorState(investorId);\n  if (existing) return existing;\n\n  const now = new Date();\n  const firstName = investorName.split(\" \")[0];\n\n  const state: InvestorState = {\n    investorId,\n    stage: \"new\",\n    hasCompletedOnboarding: false,\n    searchCount: 0,\n    snapAppCount: 0,\n    conversationHistory: [\n      {\n        id: nanoid(8),\n        role: \"assistant\",\n        content: `${firstName}, we've been expecting you.\\n\\nI'm Mino, your portfolio intelligence agent. I can help you:\\n\\n• **Search** for insights on your portfolio companies\\n• **Create Snap Apps** - live dashboards from any search\\n• **Manage settings** through natural conversation\\n\\nWhat would you like to explore first?`,\n        timestamp: now,\n        metadata: { intent: \"general\" },\n      },\n    ],\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  await kv.set(ONBOARDING_KEYS.state(investorId), state);\n  return state;\n}\n\n/**\n * Update investor state after a search\n */\nexport async function recordInvestorSearch(\n  investorId: string,\n  query: string\n): Promise<InvestorState | null> {\n  const state = await getInvestorState(investorId);\n  if (!state) return null;\n\n  const now = new Date();\n  const updated: InvestorState = {\n    ...state,\n    stage: state.stage === \"new\" ? \"searched\" : state.stage,\n    searchCount: state.searchCount + 1,\n    lastSearchQuery: query,\n    lastSearchAt: now,\n    updatedAt: now,\n  };\n\n  await kv.set(ONBOARDING_KEYS.state(investorId), updated);\n  return updated;\n}\n\n/**\n * Record snap app creation\n */\nexport async function recordSnapAppCreation(investorId: string): Promise<InvestorState | null> {\n  const state = await getInvestorState(investorId);\n  if (!state) return null;\n\n  const now = new Date();\n  const updated: InvestorState = {\n    ...state,\n    stage: \"created_app\",\n    snapAppCount: state.snapAppCount + 1,\n    hasCompletedOnboarding: true,\n    updatedAt: now,\n  };\n\n  await kv.set(ONBOARDING_KEYS.state(investorId), updated);\n  return updated;\n}\n\n/**\n * Add message to conversation history\n */\nexport async function addConversationMessage(\n  investorId: string,\n  message: Omit<ConversationMessage, \"id\" | \"timestamp\">\n): Promise<InvestorState | null> {\n  const state = await getInvestorState(investorId);\n  if (!state) return null;\n\n  const now = new Date();\n  const newMessage: ConversationMessage = {\n    ...message,\n    id: nanoid(8),\n    timestamp: now,\n  };\n\n  // Keep last 50 messages\n  const history = [...state.conversationHistory, newMessage].slice(-50);\n\n  const updated: InvestorState = {\n    ...state,\n    conversationHistory: history,\n    updatedAt: now,\n  };\n\n  await kv.set(ONBOARDING_KEYS.state(investorId), updated);\n  return updated;\n}\n\n/**\n * Check if investor can create snap apps (must have searched first)\n */\nexport function canCreateSnapApp(state: InvestorState): boolean {\n  return state.searchCount > 0;\n}\n\n// ============================================================================\n// BRIEFING SUBSCRIPTIONS\n// ============================================================================\n\nexport interface BriefingSubscription {\n  id: string;\n  userId: string;\n  name: string;\n  email?: string;\n  phone?: string;\n  topics: string[];\n  companies: string[];\n  schedule: {\n    enabled: boolean;\n    time: string; // \"06:00\" format\n    timezone: string;\n    daysOfWeek: number[]; // 0=Sunday, 1=Monday, etc.\n  };\n  deliveryMethod: \"imessage\" | \"sms\" | \"email\" | \"webhook\";\n  webhookUrl?: string;\n  isActive: boolean;\n  lastDeliveredAt?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface BriefingDelivery {\n  id: string;\n  subscriptionId: string;\n  content: string;\n  newsItems: Array<{\n    headline: string;\n    source: string;\n    url: string;\n    company?: string;\n  }>;\n  deliveredAt: Date;\n  status: \"pending\" | \"sent\" | \"failed\";\n  error?: string;\n}\n\nconst BRIEFING_KEYS = {\n  subscription: (id: string) => `briefing:${id}`,\n  userSubscriptions: (userId: string) => `user:${userId}:briefings`,\n  allActiveSubscriptions: () => `briefings:active`,\n  delivery: (id: string) => `delivery:${id}`,\n  subscriptionDeliveries: (subscriptionId: string) => `briefing:${subscriptionId}:deliveries`,\n  pendingDeliveries: () => `deliveries:pending`,\n};\n\n/**\n * Create a new briefing subscription\n */\nexport async function createBriefingSubscription(\n  data: Omit<BriefingSubscription, \"id\" | \"createdAt\" | \"updatedAt\" | \"isActive\">\n): Promise<BriefingSubscription> {\n  const id = nanoid(10);\n  const now = new Date();\n\n  const subscription: BriefingSubscription = {\n    ...data,\n    id,\n    isActive: true,\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  await kv.set(BRIEFING_KEYS.subscription(id), subscription);\n\n  // Add to user's subscriptions\n  await kv.zadd(BRIEFING_KEYS.userSubscriptions(data.userId), {\n    score: now.getTime(),\n    member: id,\n  });\n\n  // Add to active subscriptions if enabled\n  if (subscription.schedule.enabled) {\n    await kv.zadd(BRIEFING_KEYS.allActiveSubscriptions(), {\n      score: now.getTime(),\n      member: id,\n    });\n  }\n\n  return subscription;\n}\n\n/**\n * Get a briefing subscription by ID\n */\nexport async function getBriefingSubscription(id: string): Promise<BriefingSubscription | null> {\n  return kv.get<BriefingSubscription>(BRIEFING_KEYS.subscription(id));\n}\n\n/**\n * Get all subscriptions for a user\n */\nexport async function getUserBriefingSubscriptions(userId: string): Promise<BriefingSubscription[]> {\n  const ids = await kv.zrange<string>(\n    BRIEFING_KEYS.userSubscriptions(userId),\n    0,\n    -1,\n    { rev: true }\n  );\n\n  if (!ids.length) return [];\n\n  const subscriptions = await Promise.all(\n    ids.map((id) => getBriefingSubscription(id))\n  );\n\n  return subscriptions.filter((s): s is BriefingSubscription => s !== null);\n}\n\n/**\n * Get all active subscriptions (for cron job)\n */\nexport async function getAllActiveSubscriptions(): Promise<BriefingSubscription[]> {\n  const ids = await kv.zrange<string>(\n    BRIEFING_KEYS.allActiveSubscriptions(),\n    0,\n    -1\n  );\n\n  if (!ids.length) return [];\n\n  const subscriptions = await Promise.all(\n    ids.map((id) => getBriefingSubscription(id))\n  );\n\n  return subscriptions.filter(\n    (s): s is BriefingSubscription => s !== null && s.isActive && s.schedule.enabled\n  );\n}\n\n/**\n * Update a briefing subscription\n */\nexport async function updateBriefingSubscription(\n  id: string,\n  updates: Partial<Omit<BriefingSubscription, \"id\" | \"userId\" | \"createdAt\">>\n): Promise<BriefingSubscription | null> {\n  const existing = await getBriefingSubscription(id);\n  if (!existing) return null;\n\n  const updated: BriefingSubscription = {\n    ...existing,\n    ...updates,\n    updatedAt: new Date(),\n  };\n\n  await kv.set(BRIEFING_KEYS.subscription(id), updated);\n\n  // Update active subscriptions index\n  if (updated.isActive && updated.schedule.enabled) {\n    await kv.zadd(BRIEFING_KEYS.allActiveSubscriptions(), {\n      score: updated.createdAt.getTime(),\n      member: id,\n    });\n  } else {\n    await kv.zrem(BRIEFING_KEYS.allActiveSubscriptions(), id);\n  }\n\n  return updated;\n}\n\n/**\n * Delete a briefing subscription\n */\nexport async function deleteBriefingSubscription(id: string): Promise<boolean> {\n  const existing = await getBriefingSubscription(id);\n  if (!existing) return false;\n\n  await Promise.all([\n    kv.del(BRIEFING_KEYS.subscription(id)),\n    kv.zrem(BRIEFING_KEYS.userSubscriptions(existing.userId), id),\n    kv.zrem(BRIEFING_KEYS.allActiveSubscriptions(), id),\n  ]);\n\n  return true;\n}\n\n/**\n * Record a briefing delivery\n */\nexport async function recordBriefingDelivery(\n  subscriptionId: string,\n  content: string,\n  newsItems: BriefingDelivery[\"newsItems\"],\n  status: \"sent\" | \"failed\",\n  error?: string\n): Promise<BriefingDelivery> {\n  const id = nanoid(10);\n  const now = new Date();\n\n  const delivery: BriefingDelivery = {\n    id,\n    subscriptionId,\n    content,\n    newsItems,\n    deliveredAt: now,\n    status,\n    error,\n  };\n\n  await kv.set(BRIEFING_KEYS.delivery(id), delivery);\n\n  await kv.zadd(BRIEFING_KEYS.subscriptionDeliveries(subscriptionId), {\n    score: now.getTime(),\n    member: id,\n  });\n\n  // Update subscription's last delivered time\n  if (status === \"sent\") {\n    await updateBriefingSubscription(subscriptionId, {\n      lastDeliveredAt: now,\n    });\n  }\n\n  return delivery;\n}\n\n/**\n * Get delivery history for a subscription\n */\nexport async function getDeliveryHistory(\n  subscriptionId: string,\n  limit: number = 10\n): Promise<BriefingDelivery[]> {\n  const ids = await kv.zrange<string>(\n    BRIEFING_KEYS.subscriptionDeliveries(subscriptionId),\n    0,\n    limit - 1,\n    { rev: true }\n  );\n\n  if (!ids.length) return [];\n\n  const deliveries = await Promise.all(\n    ids.map((id) => kv.get<BriefingDelivery>(BRIEFING_KEYS.delivery(id)))\n  );\n\n  return deliveries.filter((d): d is BriefingDelivery => d !== null);\n}\n"],"names":["localStore","Map","localSortedSets","isKvConfigured","Boolean","process","env","KV_REST_API_URL","KV_REST_API_TOKEN","kv","vercelKv","get","localKv","key","set","value","del","delete","incr","next","current","zadd","item","existingIdx","findIndex","s","member","push","sort","a","b","score","zrem","idx","splice","zrange","start","stop","options","rev","reverse","byScore","filter","slice","map","console","log","KEYS","snapApp","id","publicSnapApps","scheduledJob","pendingJobs","getSnapApp","updateSnapApp","updates","existing","updated","updatedAt","Date","undefined","isPublic","createdAt","getTime","getPendingJobs","limit","now","jobIds","length","batchIds","Promise","all","job","isActive","completeScheduledJob","jobId","nextRunAt","intervalMinutes","updatedJob","lastRunAt","snapAppId","lastRefreshedAt"],"sourceRoot":"","ignoreList":[]}